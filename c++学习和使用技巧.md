# c++学习和使用技巧

谨以此文，记录我的22岁 ——2023年6月

# 第一阶段



## 1.字符串string

1.使用string时，需要引用头文件

```
#include<string>
```

2.不能直接打印字符串，需要增加.c_str()，例如

```c++
printf（%s，str） ------ printf（%s，str.c_str()）
```



## 2.结构体struct

1.struct定义和函数不同，需要在花括号外边写；号

2.结构体的调用时可以省略关键词struct，直接按照类似int a的方式，例如student s1

3.结构体作为函数参数时，传递方式有值传递和地址传递；通常用地址传递，占用内参只有地址的4个字节。防止误操作，加入const固定

​		值传递：形参改变，实参不会发生变化。相当于拷贝一份实参的副本

​		地址传递：形参改变，实参跟着变化。

4.struct和class一样，可以有==属性变量==和==成员函数==，在struct结构体内也可以==函数==存在。用法与class类一模一样

5.结构体实例化后的成员，也可以用取地址、指针接收的方式。但是要使用->符号代替.运算符

```c++
struct student s1
    s1.name = "zhangsan"
struct student *p = &s1
	p->name
```



## 3.一维数组作为参数传入函数

和普通的值传递有区别，数组是地址传递[(101条消息) c++中数组作为参数传入函数_c++数组作为参数传入函数_啤酒我可以喝一件的博客-CSDN博客](https://blog.csdn.net/zouxu634866/article/details/89318769)

```c++
void printinfo(int people[])或者(int *people)
{
    int main(){
    int people[3]={0,1,2};
    printinfo(people); //people并不是数组，而是第一个元素的地址，使用时只能将数组名作为参数
}
```

1.数组名就是首个元素的地址，上述printinfo实际上传的不是数组，而是首个元素的地址

2.数组传入函数时只能将数组名作为参数(***只能传入people***)，也就是只能传入首地址

3.函数定义时的形参有两种定义方式

```c++
void printinfo(int people[] , int len)或者void printinfo(int *people , int len)
```



## 4.指针

1.int*是一种数据类型，类似int，名称叫做指针。&为地址，指针存储的就是地址。

```c++
int* p = &a  //p的值为0x0011等，是一个具体的地址
```

2.*p是解引用的操作，因为p是地址，解引用相当于直接获取该地址存储的值，就可以彻底改变该地址的数据，可以形参修饰实参

3.指针常量（int* cost）：指针的指向是固定的（不可修改），指针指向的值可以修改

**二级指针：**

```c++
worker** worker_array = new worker*[5] //创建了5个work*的指针数组
//worker_array可以理解成：等号右边创建了一个指针数组，用worker_array来指向这个指针数组的初始地址
//可以用索引的方式找到特定的一级指针，例如worker_array[1]->name，可以直接访问2号工作人员的名字
```



## 5.内存四区

==程序运行前：==

**代码区**：

用来存放二进制文件，特点是具有**共享性**和**只读性**，保证多次点开exe文件时重复利用一个区域的代码，不用在开辟新的内存空间

**全局区：**

存放全局变量、静态变量（static）、常量（全局常量和字符串常量、局部常量不在该区域中）

==程序运行后：==

**栈区：**

内存的释放由编译器决定。注意事项：不要在函数中返回局部变量的地址，因为函数调用结束后，编译器会自动释放占用的内存空间，地址就不再是变量的地址了

**堆区**：

内存的释放由程序员决定，可以利用new关键词在函数中将局部变量的地址传递回来。

一个new对应一个delete，不可以多个new用一个delete来删除

返回值是指针类型：`new 数据类型`返回值为 `数据类型 *`，例如`new int`返回值为 `int *`





## 6.引用

1.**定义：**

相当于给变量另起一个名字，使得不同的变量名可以访问同一块内存地址。赋值相当于将相同的值给予不用的内存地址。二者不一样

**2.注意事项：**

​		**引用必须初始化**，必须有要改名的变量。不能直接int &b ， 而是要先定义int a ，然后int &b = a；

​		**引用一旦完成初始化，就不能再更改引用其他变量**。int &b = a后不能再操作int &b = c；

​		**引用的数据发生变化，原始数据也会一起变化**。二者同生同死

​		值返回是相当于拷贝构造函数，复制该成员，然后创建了一个新的对象。引用只会返回自身的对象

**3.本质**

引用的本质是指针常量。编译器会自动修改。int & ref = a 编译器改写为：ref =20编译器改修为：

```c++
int* const ref = &a ； *ref = 20
```

**4.常量引用的值不能再改变**，const int & ref = a表示ref的值不可以再改变，防止函数传递中形参改变实参

```c++
void showvalue(const int & a)  
{
    a = 100000; //会报错，无法修改a的值，因为函数是用常量引用接收的实参，不可以再改变引用的数据
    cout << "a="<< a <<endl;
}
```



## 7.函数高级

**1.参数传递**：

值传递（形参不改变实参），地址传递（形参改变实参），引用传递（形参改变实参）

**2.函数默认参数：**

形参中可以进行赋值，例如。同样函数也可以继续赋值，以输入的实参为准

```c++
int value(int a ,int b = 20,int c = 30)
{
    return a+b+c
}
int main()
{
	value(10,40,50)
}
```

**注意事项：**

​		第一个默认参数后，从左往右的形参都需要有默认参数

​		函数的声明和实现只能有一个默认参数

**3.占位参数：**

`返回值类型 函数名（数据类型< **无具体的形参** >）{}`

**4.函数重载：**

允许使用==相同名称==的函数，来提高复用率。函数形参列表中包括（类型不同，个数不同，顺序不同），但是返回值==需要相同==



# 第二阶段

## 8.类与对象

**1.c++三要素：**

封装，继承，多态

**2.类的特征包括：**

属性（变量），行为（函数）。类中的属性与行为，统一称为==成员==

|      | 属性     | 行为     |
| ---- | -------- | -------- |
| 别名 | 成员属性 | 成员函数 |
|      | 成员变量 | 成员方法 |

​		基本格式如下：

```c++
class student  //class关键词+定义的类名
{
public: //添加权限
    
    //属性
    int age  ……//一大堆的变量
        
    //行为
    void showname()  //一大堆的函数
    {
        cout <<…… <<endl;
    }
};
```

**3.访问权限：**

（不写的情况下，默认权限为==私有权限==，struct默认权限为==公共权限==）：

| 公共权限public        | 类内可以访问  类外可以访问                                   |
| --------------------- | ------------------------------------------------------------ |
| **保护权限**protected | **类内可以访问  类外不可以访问（继承中 子可以继承父的保护内容）** |
| **私有权限**private   | **类内可以访问  类外不可以访问（继承中 子不可以可以继承父的私有内容）** |

**4.使用技巧：**

类内成员函数的形参可以是其他类的成员，二者比较的程序就可以写成只传递一个其他类进来

类内成员变量也可以是其他类的成员，意思是在一个类内，可以让另一个类作为成员

**5.匿名对象**

创建并使用了对象，但没有为该对象分配一个明确的名称

```c++
class people
{
public:
    people(int val)
    {
        cout << "value: " << val <<endl；
    }
}；
    
int main() {
    int sum = people(10);}//并没有实例化对象
```

**6.初始化赋值**

==不要和继承搞混==

```c++
class Person {	
	int m_A;
	int m_B;
	int m_C;
	//传统方式初始化
	Person(int a, int b, int c) {
		m_A = a;
		m_B = b;
		m_C = c;}

	//初始化列表方式初始化
	Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c)
```



## 9.多文件编写：

**1..h文件是头文件：**	

里面写类的==声明==，不写定义，包括类内成员变量和成员函数，函数不写内容，只做声明部分

注意事项：首行需要添加一行代码，避免头文件之间多次调用

```c++
#pragma once
```

**2..cpp文件是源文件：**

里面只用写成员函数的==定义==，注意的点是函数名称前需要添加==作用域==，不用写class类、不用设置权限

注意事项：引用自定义的.h文件时，需要用" "与标准库函数中的< >区分

```c++
#include "circle.h"  //与<iostream>区分
```

**3.注意事项：**

1.声明文件中写类的定义，按照常规类的写法，例如

```c++
#pragma once
class people
{
public:
    string name;
    int age;
    people(int age,string name); //构造函数
    void show_info();
};
```

2.实现文件中==不要再写成类的写法==了，否则会报错类重复定义，应该改成以下这种：

```c++
#include "people.h"

people::people(int age,string name)
{
    this->age = age;
    this->name = name;
}

void people::show_info()
{
    cout<<"年龄为："<<age<<"姓名为"<<name<<endl;
}
```

**4.如何进行多文件编写**

比如说src文件夹中有2个cpp文件（A.cpp和B.cpp），但是只有A.cpp文件中有main函数，想在这个main函数的cpp文件中调用B.cpp文件的函数，此时就需要对B.cpp进行多文件的编写，将B.cpp中所有的函数声明写成B.h的形式，然后将B.cpp改写成函数的实现。在A.cpp调用时，只需要引入B.h的库文件即可调用B.cpp中的函数

**5.编译器改正：**

vscode编译器：

tasks.josn文件中下修改，表示编译==文件夹==所有cpp文件

```c++
“args”:[
    "${file}"                //单个文件编译，只适用于cpp文件中不牵扯其他cpp文件的单个文件
	"${fileDirname}\\*.cpp"  //多个文件编译，适用于同时编译声明和定义分开的多个cpp文件
```



## 10.析构函数

作用：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作

编译器：如果**不提供构造和析构，编译器会提供**，编译器提供的构造函数和析构函数是**空实现**

语法：**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

误解：析构函数在类成员释放前执行（就是函数释放前执行），并不是在定义完类成员后就释放

```c++
void test()
{
	people p1;
    //这里不会调用析构函数
	cout <<...<<endl;
	people p2;
	cout << ...<<endl;
    //在这里才会调用析构函数进行释放
}
```



## 11.构造函数

**定义**：在创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

**分类**：

​	按参数分为： 有参构造和无参构造

​	按类型分为： 普通构造和拷贝构造



## 12.拷贝构造函数

```c++
class Person {
public:
	int mAge；
	Person(const Person& p) 
    {
		cout << "拷贝构造函数!" << endl;
		mAge = p.mAge;
	}
}；
```

编译器提供规则：

|  无  |     拷贝     | 有参（自己） |
| :--: | :----------: | :----------: |
|  无  | 拷贝（自己） |      无      |

**1.浅拷贝：**

简单的赋值操作，原理是赋值旧对象的指针，新旧对象共享一块地址。编译器默认提供浅拷贝

注意：浅拷贝遇见堆区数据（比如有参构造里利用new在堆区开辟了一个空间），如果两个带有delete的析构函数同时作用于一个地址		（交叉重复释放），是非法操作

总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

**2.深拷贝：**

在堆区重新申请空间，进行拷贝操作

```c++
class Person{
public:
    int * m_height;
    //拷贝构造
	Person(const Person& p)
	{
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
        //新开辟一块空间，就不会造成新旧成员的析构函数同时作用于同一个地址
		m_height = new int(*p.m_height);	
	}
    //析构函数
    ~people()
    {
        if (m_height!=NULL)
        {
            delete m_height;
            m_height = NULL;
        }
    }
};
```

如果利用new了多个对象，不可以用一个delete同时释放，delete后面需要跟变量名称



## 13.this指针

this指针本质上就是类实例化对象后，对象的首地址，所以this指针对成员的所有都可以访问

this指针的本质是一个指针常量 ：指针的指向不可修改，指针指向的值可以修改

return * this的返回值是类本身 

静态成员函数内不能调用this指针，是先于对象存在的



## 14.const相关

常量指针：不可改变指针的内容 `const int * a  `

指针常量：不可改变指针的指向 `int * const a`

常函数：

类内成员函数在后面加上const后，成员变量在成员函数内就不可以修改：特殊关键字mutable

成员函数相当于调用this指针，this本质是指针常量，只能修改指向的值，相当于在this之前再加了一个const

常对象：

在对象前面加上const，并不是在成员属性前面

常对象只能调用常函数，因为普通成员函数可以允许修改成员属性的值



## 15.static相关

静态成员变量 特点 意义

静态成员函数 特点 意义

private的意义



## 16.友元：（访问私有成员）

**1.全局函数做友元：**

​		在class建立后在public前面加上`friend+全局函数的声明,eg:friend void test(int a);`

**2.类做友元：**

​		在class建立后在public前面加上`friend+class 类名；`

​		注意：另一个类A做友元时，必须在该类B之前**定义或者声明**，具体函数实现可以在该类之后用作用域的方式实现

**3.成员函数做友元：**

`		friend void 类名::函数名(数据类型 形参)；eg：friend void people::test(int a);`

​		注意：另一个类A必须在该类B之前定义，A可以在后面写具体实现，但是A类内所有的**定义**必须在该类B之前



## 17.运算符重载

运算符重载也可以发生函数重载，例如：`operator+（person &p,person &p2）和 operator+(person& p1,int num)`

赋值运算符chongzai_4有问题没解决，58行改写成p2（20，“李四”，30.0），p2=p1就没问题？



## 18.继承

1.**基本语法**：父类/基类+子类/派生类

```c++
//父类
class base
{
    public:
    int dad_age;
    protected:
    private:
};

//子类
class son : public base //public/private/protected三选一作为继承方式
{
    public:
    int son_age;
}
```

2.**继承方式**：

|         public         |        private        |       protected       |
| :--------------------: | :-------------------: | :-------------------: |
| **保留父类的规则不变** |  **全部变为private**  | **全部变为protected** |
|     public->public     |    public->private    |   public->protected   |
|  protected->protected  |    public->private    | protected->protected  |
| private->**不可访问**  | private->**不可访问** | private->**不可访问** |

注意：父类中的私有成员只是被**隐藏**了，依旧会被继承到子类中

**3.构造函数和析构函数**：父类构造->子类构造->子类析构->父类析构

**4.子类和父类同名的调用**：父类成员要加**作用域**

例子：父类为base，子类为son，实例化子类成员为s ，重名的分别为age，show_func()，static_age，static_func()

|      |    成员属性     |        成员函数         |  静态属性（对象调用）  |   静态属性（类名调用）    |   静态函数（对象调用）    |     静态函数（类名调用）     |
| ---- | :-------------: | :---------------------: | :--------------------: | :-----------------------: | :-----------------------: | :--------------------------: |
| 子类 |      s.age      |      s.show_func()      |      s.static_age      |      son::static_age      |      s.static_func()      |      son::static_func()      |
| 父类 | s.**base**::age | s.**base**::show_func() | s.**base**::static_age | son::**base**::static_age | s.**base**::static_func() | son::**base**::static_func() |

注意：`son::base::static_age`中前后两个::代表的含义不同。第一个表示用**类名调用**的意思，第二个是作用域的意思

5.**多继承**：`class son : public base1 , public base2`同一个子类可以继承多个父类。同名时需用不同作用域分开

6.**菱形继承的问题：** 一方面会引起最底层类的成员属性二义性，另一方面会对祖先类重复继承。

​		解决：中间层采用虚继承的方式 `class sheep : virtual public animal`

7.子类继承父类后，如果函数的形参为**父类**的引用或者指针，可以传入**子类**的实参，**反之不行**



## 19.多态

1类内成员函数在哪存储，类内虚函数在哪存储，修改子类可以改变父类吗

如果是空的类，sizeof为1

2.**多态的使用**：

​			步骤1：父类改写成虚函数，

​			步骤2：子类重写虚函数（先需要继承）

​			步骤3：父类的指针或者==引用？==接收子类的地址

​			示例：

```c++
class father
{
public:
    virtual void show() //改写成虚函数
    {
        cout<<"判断是否可以实例化"<<endl; //当然也可以写成纯虚函数
    }
};

class son : public father
{
    virtual void show() //重写虚函数
    {
        cout<<"son的输出"<<endl;
    }
}；
int main()
{
    father * = new son //父类的指针或者引用接收子类的地址
}
```

3.**抽象类**：父类函数中没有任何函数，用=0表示，称为**纯虚函数**。

```c++
class father
{
public:
    virtual void show()=0；
};
```

抽象类无法==**实例化**==



## 20.读写文件

**流对象分类和打开方式：**

1. ofstream：写操作
2. ifstream： 读操作
3. fstream ： 读写操作

| 打开方式    | 解释                       |
| ----------- | -------------------------- |
| ios::in     | 为读文件而打开文件         |
| ios::out    | 为写文件而打开文件         |
| ios::ate    | 初始位置：文件尾           |
| ios::app    | 追加方式写文件             |
| ios::trunc  | 如果文件存在先删除，再创建 |
| ios::binary | 二进制方式                 |

如果打开方式有多个，可以用或操作运算符，例如 ios::in|ios::out

**1.读文件：**五步走

1. 包含头文件   

   \#include <fstream\>

2. 创建流对象  

   ifstream ifs;

3. 打开文件并判断文件是否打开成功

   ifs.open("文件路径",打开方式);

4. 读数据

   四种方式读取

5. 关闭文件

   ifs.close();

```c++
#include <fstream>
#include <string>
void test01()
{
	ifstream ifs;
	ifs.open("test.txt", ios::in); //可以该路径，如果不改就是默认文件所在的位置

    if (!ifs.is_open())
    {
        cout << "文件打开失败" << endl;
        return;
    }

    //第一种方式
    char buf[1024] = { 0 };
    while (ifs >> buf)
    {
    	cout << buf << endl;
    }

    //第二种
    char buf[1024] = { 0 };
    while (ifs.getline(buf,sizeof(buf)))
    {
    	cout << buf << endl;
    }

    //第三种
    string line;
    //getline会逐行遍历文件，并将每一行都存储在line变量中，line表示循环中每一行的数据
    while (getline(ifs, line)) //这里的getline第一个参数一定是输入流，不是文件名称，切记切结
    {
    	cout << line << endl;
    }

	ifs.close();
```

**2.写文件**：五步走

1. 包含头文件   

   \#include <fstream\>

2. 创建流对象  

   ofstream ofs;

3. 打开文件

   ofs.open("文件路径",打开方式);

4. 写数据

   ofs << "写入的数据";

5. 关闭文件

   ofs.close();

```c++
#include <fstream>

void test01()
{
	ofstream ofs;
	ofs.open("test.txt", ios::out); //可以该路径，如果不改就是默认文件所在的位置
    ofs << "姓名：张三" << endl;
    ofs << "性别：男" << endl;
    ofs << "年龄：18" << endl;
    ofs.close();
}
int main() {
	test01();
	system("pause");
	return 0;
}
```

**3.判断文件中是否有数据：**读取文件后，文件流利用eof函数

```c++
char h
ifs>>h;
if(ifs.eof())
{
    cout<<"文件为空"<<endl;
}
```

**4.读取每一行中的数据：**

```c++
while(ifs >>id && ifs >> name && ifs >> did)
```

1. 从输入流 `ifs` 中尝试提取一个整数，并将其赋值给变量 `id`。
2. 如果提取成功，则继续尝试从输入流中提取一个字符串，并将其赋值给变量 `name`。
3. 如果第二次提取也成功，则继续尝试从输入流中提取一个整数，并将其赋值给变量 `did`。
4. 如果以上所有的提取操作都成功，表达式的结果为真（`true`），进入 `while` 循环体。否则，循环结束。



## 21.new相关

**定义：**new用来在堆区手动开辟一块内存，需要注意的是返回值是对应类型的指针

​			需要delete手动释放开辟的内存空间

**区分**：区分（）和[ ]两种方式

```c++
int* a = new int(5)  //表示新开辟了一个单独的int空间，初始化数据为5
int* b = new int[5]  //表示新开辟了一个包含5个整形的数组，无初始化
    //如果需要初始化，可以写成int* b = new int[5]{1,2,3,4,5}
worker** c = new worker*[5]  
    //c[0]代表在这个指针数组中第一个元素的指针，注意为一级指针，不是二级指针，可以用c[0]->name直接访问人员姓名
```

**释放**：指针数组释放需要加上[]，指针数组也可以单个释放

```c++
delete a;  //正常释放即可
delete[] a;  //表示释放的是一个开辟的数据
delete a[2]; //只释放a指针数组中的第3个成员的指针，也可以后面重新赋值
```

**new数组应用**：一般来说new数组是为了动态管理数组的大小，比vector稍微快一些

```c++
// 动态添加元素
int *arr = new int[5];
for (int i = 0; i < 5; ++i) {
    arr[i] = i;
}
// 在运行时添加更多的元素
int newSize = 10;
int *newArr = new int[newSize];
for (int i = 0; i < 5; ++i) {
    newArr[i] = arr[i];
}
delete[] arr;  // 释放原数组的内存
arr = newArr;  // 更新指针
```

